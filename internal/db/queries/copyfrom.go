// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: copyfrom.go

package queries

import (
	"context"
)

// iteratorForAssignCategoriesToTargets implements pgx.CopyFromSource.
type iteratorForAssignCategoriesToTargets struct {
	rows                 []AssignCategoriesToTargetsParams
	skippedFirstNextCall bool
}

func (r *iteratorForAssignCategoriesToTargets) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForAssignCategoriesToTargets) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].DishID,
		r.rows[0].CommodityID,
		r.rows[0].CategoryID,
	}, nil
}

func (r iteratorForAssignCategoriesToTargets) Err() error {
	return nil
}

func (q *Queries) AssignCategoriesToTargets(ctx context.Context, arg []AssignCategoriesToTargetsParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"categories_to_targets"}, []string{"dish_id", "commodity_id", "category_id"}, &iteratorForAssignCategoriesToTargets{rows: arg})
}

// iteratorForAssignOrdersCommoditiesAndDishes implements pgx.CopyFromSource.
type iteratorForAssignOrdersCommoditiesAndDishes struct {
	rows                 []AssignOrdersCommoditiesAndDishesParams
	skippedFirstNextCall bool
}

func (r *iteratorForAssignOrdersCommoditiesAndDishes) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForAssignOrdersCommoditiesAndDishes) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].OrderID,
		r.rows[0].DishID,
		r.rows[0].CommodityID,
	}, nil
}

func (r iteratorForAssignOrdersCommoditiesAndDishes) Err() error {
	return nil
}

func (q *Queries) AssignOrdersCommoditiesAndDishes(ctx context.Context, arg []AssignOrdersCommoditiesAndDishesParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"orders_composition"}, []string{"order_id", "dish_id", "commodity_id"}, &iteratorForAssignOrdersCommoditiesAndDishes{rows: arg})
}

// iteratorForCreateCategories implements pgx.CopyFromSource.
type iteratorForCreateCategories struct {
	rows                 []string
	skippedFirstNextCall bool
}

func (r *iteratorForCreateCategories) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForCreateCategories) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0],
	}, nil
}

func (r iteratorForCreateCategories) Err() error {
	return nil
}

func (q *Queries) CreateCategories(ctx context.Context, name []string) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"categories"}, []string{"name"}, &iteratorForCreateCategories{rows: name})
}

// iteratorForCreateCommodities implements pgx.CopyFromSource.
type iteratorForCreateCommodities struct {
	rows                 []CreateCommoditiesParams
	skippedFirstNextCall bool
}

func (r *iteratorForCreateCommodities) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForCreateCommodities) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].SupplierID,
		r.rows[0].Name,
		r.rows[0].Cost,
		r.rows[0].Image,
		r.rows[0].Ingredients,
		r.rows[0].Weight,
		r.rows[0].Rating,
	}, nil
}

func (r iteratorForCreateCommodities) Err() error {
	return nil
}

func (q *Queries) CreateCommodities(ctx context.Context, arg []CreateCommoditiesParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"commodities"}, []string{"supplier_id", "name", "cost", "image", "ingredients", "weight", "rating"}, &iteratorForCreateCommodities{rows: arg})
}

// iteratorForCreateCourieres implements pgx.CopyFromSource.
type iteratorForCreateCourieres struct {
	rows                 []CreateCourieresParams
	skippedFirstNextCall bool
}

func (r *iteratorForCreateCourieres) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForCreateCourieres) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].Name,
		r.rows[0].Phone,
		r.rows[0].Rating,
	}, nil
}

func (r iteratorForCreateCourieres) Err() error {
	return nil
}

func (q *Queries) CreateCourieres(ctx context.Context, arg []CreateCourieresParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"couriers"}, []string{"name", "phone", "rating"}, &iteratorForCreateCourieres{rows: arg})
}

// iteratorForCreateDishes implements pgx.CopyFromSource.
type iteratorForCreateDishes struct {
	rows                 []CreateDishesParams
	skippedFirstNextCall bool
}

func (r *iteratorForCreateDishes) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForCreateDishes) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].SupplierID,
		r.rows[0].Name,
		r.rows[0].Cost,
		r.rows[0].Image,
		r.rows[0].Ingredients,
		r.rows[0].Weight,
		r.rows[0].Calories,
		r.rows[0].Allergens,
		r.rows[0].Rating,
	}, nil
}

func (r iteratorForCreateDishes) Err() error {
	return nil
}

func (q *Queries) CreateDishes(ctx context.Context, arg []CreateDishesParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"dishes"}, []string{"supplier_id", "name", "cost", "image", "ingredients", "weight", "calories", "allergens", "rating"}, &iteratorForCreateDishes{rows: arg})
}

// iteratorForCreateOrders implements pgx.CopyFromSource.
type iteratorForCreateOrders struct {
	rows                 []CreateOrdersParams
	skippedFirstNextCall bool
}

func (r *iteratorForCreateOrders) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForCreateOrders) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].UserID,
		r.rows[0].Timestamp,
		r.rows[0].SourceAddress,
		r.rows[0].TargetAddress,
		r.rows[0].CourierID,
		r.rows[0].Status,
		r.rows[0].PaymentID,
	}, nil
}

func (r iteratorForCreateOrders) Err() error {
	return nil
}

func (q *Queries) CreateOrders(ctx context.Context, arg []CreateOrdersParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"orders"}, []string{"user_id", "timestamp", "source_address", "target_address", "courier_id", "status", "payment_id"}, &iteratorForCreateOrders{rows: arg})
}

// iteratorForCreatePayments implements pgx.CopyFromSource.
type iteratorForCreatePayments struct {
	rows                 []CreatePaymentsParams
	skippedFirstNextCall bool
}

func (r *iteratorForCreatePayments) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForCreatePayments) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].Method,
		r.rows[0].Status,
	}, nil
}

func (r iteratorForCreatePayments) Err() error {
	return nil
}

func (q *Queries) CreatePayments(ctx context.Context, arg []CreatePaymentsParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"payments"}, []string{"method", "status"}, &iteratorForCreatePayments{rows: arg})
}

// iteratorForCreateSuppliers implements pgx.CopyFromSource.
type iteratorForCreateSuppliers struct {
	rows                 []CreateSuppliersParams
	skippedFirstNextCall bool
}

func (r *iteratorForCreateSuppliers) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForCreateSuppliers) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].Name,
		r.rows[0].WorkTimeStart,
		r.rows[0].WorkTimeEnd,
		r.rows[0].Rating,
		r.rows[0].Address,
	}, nil
}

func (r iteratorForCreateSuppliers) Err() error {
	return nil
}

func (q *Queries) CreateSuppliers(ctx context.Context, arg []CreateSuppliersParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"suppliers"}, []string{"name", "work_time_start", "work_time_end", "rating", "address"}, &iteratorForCreateSuppliers{rows: arg})
}

// iteratorForCreateUserAddresses implements pgx.CopyFromSource.
type iteratorForCreateUserAddresses struct {
	rows                 []CreateUserAddressesParams
	skippedFirstNextCall bool
}

func (r *iteratorForCreateUserAddresses) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForCreateUserAddresses) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].UserID,
		r.rows[0].Address,
	}, nil
}

func (r iteratorForCreateUserAddresses) Err() error {
	return nil
}

func (q *Queries) CreateUserAddresses(ctx context.Context, arg []CreateUserAddressesParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"user_addresses"}, []string{"user_id", "address"}, &iteratorForCreateUserAddresses{rows: arg})
}

// iteratorForCreateUserCards implements pgx.CopyFromSource.
type iteratorForCreateUserCards struct {
	rows                 []CreateUserCardsParams
	skippedFirstNextCall bool
}

func (r *iteratorForCreateUserCards) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForCreateUserCards) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].UserID,
		r.rows[0].Number,
	}, nil
}

func (r iteratorForCreateUserCards) Err() error {
	return nil
}

func (q *Queries) CreateUserCards(ctx context.Context, arg []CreateUserCardsParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"user_cards"}, []string{"user_id", "number"}, &iteratorForCreateUserCards{rows: arg})
}

// iteratorForCreateUsers implements pgx.CopyFromSource.
type iteratorForCreateUsers struct {
	rows                 []CreateUsersParams
	skippedFirstNextCall bool
}

func (r *iteratorForCreateUsers) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForCreateUsers) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].Name,
		r.rows[0].Surname,
		r.rows[0].Email,
		r.rows[0].Phone,
		r.rows[0].PasswordHash,
	}, nil
}

func (r iteratorForCreateUsers) Err() error {
	return nil
}

func (q *Queries) CreateUsers(ctx context.Context, arg []CreateUsersParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"users"}, []string{"name", "surname", "email", "phone", "password_hash"}, &iteratorForCreateUsers{rows: arg})
}
